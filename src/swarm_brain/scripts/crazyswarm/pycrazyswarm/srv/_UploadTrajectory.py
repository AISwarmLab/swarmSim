# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from hello_vscode/UploadTrajectoryRequest.msg. Do not edit."""
import codecs
import sys

python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import pycrazyswarm.msg


class UploadTrajectoryRequest(genpy.Message):
    _md5sum = "9e4893f8815a31a5dd11fb92d3d31a34"
    _type = "hello_vscode/UploadTrajectoryRequest"
    _has_header = False  # flag to mark the presence of a Header object
    _full_text = """uint8 id
uint8 trajectoryId
uint32 pieceOffset
TrajectoryPolynomialPiece[] pieces

================================================================================
MSG: hello_vscode/TrajectoryPolynomialPiece
#

float32[] px
float32[] py
float32[] pz
float32[] pyaw
float32 duration"""
    __slots__ = ['id', 'trajectoryId', 'pieceOffset', 'pieces']
    _slot_types = ['uint8', 'uint8', 'uint32', 'hello_vscode/TrajectoryPolynomialPiece[]']

    def __init__(self, *args, **kwds):
        """
        Constructor. Any message fields that are implicitly/explicitly
        set to None will be assigned a default value. The recommend
        use is keyword arguments as this is more robust to future message
        changes.  You cannot mix in-order arguments and keyword arguments.

        The available fields are:
           id,trajectoryId,pieceOffset,pieces

        :param args: complete set of field values, in .msg order
        :param kwds: use keyword arguments corresponding to message field names
        to set specific fields.
        """
        if args or kwds:
            super(UploadTrajectoryRequest, self).__init__(*args, **kwds)
            # message fields cannot be None, assign default values for those that are
            if self.id is None:
                self.id = 0
            if self.trajectoryId is None:
                self.trajectoryId = 0
            if self.pieceOffset is None:
                self.pieceOffset = 0
            if self.pieces is None:
                self.pieces = []
        else:
            self.id = 0
            self.trajectoryId = 0
            self.pieceOffset = 0
            self.pieces = []

    def _get_types(self):
        """
        internal API method
        """
        return self._slot_types

    def serialize(self, buff):
        """
        serialize message into buffer
        :param buff: buffer, ``StringIO``
        """
        try:
            _x = self
            buff.write(_get_struct_2BI().pack(_x.id, _x.trajectoryId, _x.pieceOffset))
            length = len(self.pieces)
            buff.write(_struct_I.pack(length))
            for val1 in self.pieces:
                length = len(val1.px)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf' % length
                buff.write(struct.Struct(pattern).pack(*val1.px))
                length = len(val1.py)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf' % length
                buff.write(struct.Struct(pattern).pack(*val1.py))
                length = len(val1.pz)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf' % length
                buff.write(struct.Struct(pattern).pack(*val1.pz))
                length = len(val1.pyaw)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf' % length
                buff.write(struct.Struct(pattern).pack(*val1.pyaw))
                _x = val1.duration
                buff.write(_get_struct_f().pack(_x))
        except struct.error as se:
            self._check_types(
                struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
        except TypeError as te:
            self._check_types(
                ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

    def deserialize(self, str):
        """
        unpack serialized message in str into this message instance
        :param str: byte array of serialized message, ``str``
        """
        if python3:
            codecs.lookup_error("rosmsg").msg_type = self._type
        try:
            if self.pieces is None:
                self.pieces = None
            end = 0
            _x = self
            start = end
            end += 6
            (_x.id, _x.trajectoryId, _x.pieceOffset,) = _get_struct_2BI().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            self.pieces = []
            for i in range(0, length):
                val1 = pycrazyswarm.msg.TrajectoryPolynomialPiece()
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf' % length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val1.px = s.unpack(str[start:end])
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf' % length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val1.py = s.unpack(str[start:end])
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf' % length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val1.pz = s.unpack(str[start:end])
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf' % length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val1.pyaw = s.unpack(str[start:end])
                start = end
                end += 4
                (val1.duration,) = _get_struct_f().unpack(str[start:end])
                self.pieces.append(val1)
            return self
        except struct.error as e:
            raise genpy.DeserializationError(e)  # most likely buffer underfill

    def serialize_numpy(self, buff, numpy):
        """
        serialize message with numpy array types into buffer
        :param buff: buffer, ``StringIO``
        :param numpy: numpy python module
        """
        try:
            _x = self
            buff.write(_get_struct_2BI().pack(_x.id, _x.trajectoryId, _x.pieceOffset))
            length = len(self.pieces)
            buff.write(_struct_I.pack(length))
            for val1 in self.pieces:
                length = len(val1.px)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf' % length
                buff.write(val1.px.tostring())
                length = len(val1.py)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf' % length
                buff.write(val1.py.tostring())
                length = len(val1.pz)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf' % length
                buff.write(val1.pz.tostring())
                length = len(val1.pyaw)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf' % length
                buff.write(val1.pyaw.tostring())
                _x = val1.duration
                buff.write(_get_struct_f().pack(_x))
        except struct.error as se:
            self._check_types(
                struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
        except TypeError as te:
            self._check_types(
                ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

    def deserialize_numpy(self, str, numpy):
        """
        unpack serialized message in str into this message instance using numpy for array types
        :param str: byte array of serialized message, ``str``
        :param numpy: numpy python module
        """
        if python3:
            codecs.lookup_error("rosmsg").msg_type = self._type
        try:
            if self.pieces is None:
                self.pieces = None
            end = 0
            _x = self
            start = end
            end += 6
            (_x.id, _x.trajectoryId, _x.pieceOffset,) = _get_struct_2BI().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            self.pieces = []
            for i in range(0, length):
                val1 = pycrazyswarm.msg.TrajectoryPolynomialPiece()
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf' % length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val1.px = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf' % length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val1.py = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf' % length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val1.pz = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf' % length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val1.pyaw = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
                start = end
                end += 4
                (val1.duration,) = _get_struct_f().unpack(str[start:end])
                self.pieces.append(val1)
            return self
        except struct.error as e:
            raise genpy.DeserializationError(e)  # most likely buffer underfill


_struct_I = genpy.struct_I


def _get_struct_I():
    global _struct_I
    return _struct_I


_struct_2BI = None


def _get_struct_2BI():
    global _struct_2BI
    if _struct_2BI is None:
        _struct_2BI = struct.Struct("<2BI")
    return _struct_2BI


_struct_f = None


def _get_struct_f():
    global _struct_f
    if _struct_f is None:
        _struct_f = struct.Struct("<f")
    return _struct_f


# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from hello_vscode/UploadTrajectoryResponse.msg. Do not edit."""
import codecs
import sys

python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class UploadTrajectoryResponse(genpy.Message):
    _md5sum = "d41d8cd98f00b204e9800998ecf8427e"
    _type = "hello_vscode/UploadTrajectoryResponse"
    _has_header = False  # flag to mark the presence of a Header object
    _full_text = """
"""
    __slots__ = []
    _slot_types = []

    def __init__(self, *args, **kwds):
        """
        Constructor. Any message fields that are implicitly/explicitly
        set to None will be assigned a default value. The recommend
        use is keyword arguments as this is more robust to future message
        changes.  You cannot mix in-order arguments and keyword arguments.

        The available fields are:


        :param args: complete set of field values, in .msg order
        :param kwds: use keyword arguments corresponding to message field names
        to set specific fields.
        """
        if args or kwds:
            super(UploadTrajectoryResponse, self).__init__(*args, **kwds)

    def _get_types(self):
        """
        internal API method
        """
        return self._slot_types

    def serialize(self, buff):
        """
        serialize message into buffer
        :param buff: buffer, ``StringIO``
        """
        try:
            pass
        except struct.error as se:
            self._check_types(
                struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
        except TypeError as te:
            self._check_types(
                ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

    def deserialize(self, str):
        """
        unpack serialized message in str into this message instance
        :param str: byte array of serialized message, ``str``
        """
        if python3:
            codecs.lookup_error("rosmsg").msg_type = self._type
        try:
            end = 0
            return self
        except struct.error as e:
            raise genpy.DeserializationError(e)  # most likely buffer underfill

    def serialize_numpy(self, buff, numpy):
        """
        serialize message with numpy array types into buffer
        :param buff: buffer, ``StringIO``
        :param numpy: numpy python module
        """
        try:
            pass
        except struct.error as se:
            self._check_types(
                struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
        except TypeError as te:
            self._check_types(
                ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

    def deserialize_numpy(self, str, numpy):
        """
        unpack serialized message in str into this message instance using numpy for array types
        :param str: byte array of serialized message, ``str``
        :param numpy: numpy python module
        """
        if python3:
            codecs.lookup_error("rosmsg").msg_type = self._type
        try:
            end = 0
            return self
        except struct.error as e:
            raise genpy.DeserializationError(e)  # most likely buffer underfill


_struct_I = genpy.struct_I


def _get_struct_I():
    global _struct_I
    return _struct_I


class UploadTrajectory(object):
    _type = 'hello_vscode/UploadTrajectory'
    _md5sum = '9e4893f8815a31a5dd11fb92d3d31a34'
    _request_class = UploadTrajectoryRequest
    _response_class = UploadTrajectoryResponse
